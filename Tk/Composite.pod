
=head1 NAME 


Defining a new composite widget class

=head1 SYNOPSIS


  package Whatever;
  @ISA = qw(Tk::Frame);  # or Tk::Toplevel
         
  Tk::Widget->Construct('Whatever'); 
         
  sub Populate 
  {      
   my ($cw,$args) = @_;
         
   my $flag = delete $args->{-flag};
   if (defined $flag)
    {    
     # handle -flag => xxx which can only be done at create time
     # the delete above ensures that new() does not try and
     # do $cw->configure(-flag => xxx)
    }    
         
   $w = $cw->Component(...);
         
   $cw->Delegates(...);
   $cw->ConfigSpecs('-cursor' =>     [SELF,cursor,Cursor,undef],
                    '-something'  => [METHOD,dbName,dbClass,'default'],
                    '-text'       => [$label,dbName,dbClass,'default'],
                    '-heading'    => [Tk::Config->new($head,-text),heading,Heading,'My Heading']
                   ); 
  }      
         
  sub something
  {      
   my ($cw,$value) = @_;
   if (@_ > 1)
    {    
     # set it 
    }    
   return # current value
  }      
         
  1;     
  __END__

=head1 DESCRIPTION

The intention behind a composite is to create a higher-level widget, 
sometime called a "super-widget".  Most often, a composite will be
built upon other widgets by B<using> them, as opposed to specializing on them.  
For example, the supplied composite widget C<LabEntry> is B<made of> an
C<Entry> and a C<Label>; it is neither a B<kind-of> C<Label>
nor is it a B<kind-of> C<Entry>.

Most of the work of a composite widget consist in creating subwidgets, 
arrange to dispatch configure options to the proper subwidgets and manage
composite-specific configure options.

=head2 Composite widget creation


Since C<pTk> is heavilly using an object-oriented approach, it is no
suprise that creating a composite goes through a C<new()> method.
However, the composite does not normally define a C<new()> method
itself: it is usually sufficient to simply inherit it from
C<Tk::Widget>.  

This is what happens when the composite use


	@ISA = qw(Tk::Frame);  # or Tk::Toplevel

to specify its inheritance chain.  To complete the initialisation of the
widget, it must call the C<Construct> method from class C<Widget>.  That
method accepts the name of the new class to create, i.e. the package name
of your composite widget:


	Tk::Widget->Construct('Whatever'); 

Here, C<Whatever> is the package name (aka the widget's B<class>).  This
will define a constructor method for C<Whatever>, named after the 
widget's class.  Instanciating that composite in client code would
the look like:

	$top = MainWindow->new();   # Creates a top-level main window
	$cw = $top->Whatever();     # Creates an instance of composite widget
                                    # 'Whatever'

Whenever a composite is instanciated in client code,
C<Tk::Widget::new()> will be invoked via the widget's class
constructor.  That C<new()> method will call 


	$cw->InitObject(\%args);

where C<%args> is the arguments passed to the widget's constructor.  Note
that C<InitObject> receives a B<reference> to the hash array
containing all arguments.

For composite widgets that needs an underlying frame, C<InitObject>
will typically be inherited from C<Tk::Frame>, that is, no method of
this name will appear in the composite package.  For composites that
don't need a frame, C<InitObject> will typically be defined in the
composite class (package).  Compare the C<LabEntry> composite with 
C<Optionmenu>: the former is C<Frame> based while the latter is C<Widget> 
based.

In C<Frame> based composites, C<Tk::Frame::InitObject()> will call
C<Populate()>, which should be defined to create the characteristic
subwidgets of the class.

C<Widget> based composites don't need an extra C<Populate> layer; they
typically have their own C<InitObject> method that will create subwidgets.

=head2 Creating Subwidgets


Subwidget creation happens usually in C<Populate()> (C<Frame> based) 
or C<InitObject()> (C<Widget> based).  The composite usually calls the
subwidget's constructor method either directly, for "private" subwidgets, 
or indirectly through the C<Component> method for subwidgets that should
be advertised to clients.

C<Populate> may call C<Delegates> to direct calls to methods 
of chosen subwidgets. For simple composites, typically most if not all 
methods are directed
to a single subwidget - e.g. C<ScrolledListbox> directs all methods to the core
C<Listbox> so that $composite->get(...) calls $listbox->get(...). 

B<Further steps for >C<Frame> B<based composites>

C<Populate> should also call C<ConfigSpecs()> to specify the
way that configure-like options should be handled in the composite.
Once C<Populate> returns, method C<Tk::Frame::ConfigDefault>
walks through the C<ConfigSpecs> entries and populates
%$args hash with defaults for options from X resources (.Xdefaults, etc).

When  C<InitObject()> returns to C<Tk::Widget::new()>, 
a call to $cw->configure(%$args) is made which sets *all* the options.


