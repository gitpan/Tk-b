<HTML>
<! Copyright (c) 1994-1995 Sun Microsystems, Inc.-->
<! See the file "license.terms" for information on usage and redistribution-->
<! of this file, and for a DISCLAIMER OF ALL WARRANTIES.-->
<! -->
<! @(#) CrtItemType.3 1.4 95/05/06 15:31:44-->
<! -->
<H1>Tk_CreateItemType</H1>
<HR>
<A NAME=NAME><H2>NAME</H2>
</A>Tk_CreateItemType, Tk_GetItemTypes - define new kind of canvas item
<A NAME=SYNOPSIS><H2>SYNOPSIS</H2>
</A><BR>
<B>#include &lt;tk.h&gt;</B><BR>
<P>
<B>Tk_CreateItemType</B>(<I>typePtr</I>)<BR>
<P>
Tk_ItemType *<BR>
<B>Tk_GetItemTypes</B>()<BR>
<A NAME=ARGUMENTS><H2>ARGUMENTS</H2>
</A><DL>
<DT><CODE>Tk_ItemType *typePtr</CODE>
(in) <DD>Structure that defines the new type of canvas item.<BR>
</DL>
<HR>
<BR>
<A NAME=INTRODUCTION><H2>INTRODUCTION</H2>
</A><P>
<B>Tk_CreateItemType</B> is invoked to define a new kind of canvas item<BR>
described by the <I>typePtr</I> argument.<BR>
An item type corresponds to a particular value of the <I>type</I><BR>
argument to the <B>create</B> widget command for canvases, and<BR>
the code that implements a canvas item type is called a <I>type manager</I>.<BR>
Tk defines several built-in item types, such as <B>rectangle</B><BR>
and <B>text</B> and <B>image</B>, but <B>Tk_CreateItemType</B><BR>
allows additional item types to be defined.<BR>
Once <B>Tk_CreateItemType</B> returns, the new item type may be used<BR>
in new or existing canvas widgets just like the built-in item<BR>
types.<BR>
<P>
<B>Tk_GetItemTypes</B> returns a pointer to the first in the list<BR>
of all item types currently defined for canvases.<BR>
The entries in the list are linked together through their<BR>
<I>nextPtr</I> fields, with the end of the list marked by a<BR>
NULL <I>nextPtr</I>.<BR>
<P>
You may find it easier to understand the rest of this manual entry<BR>
by looking at the code for an existing canvas item type such as<BR>
bitmap (file tkCanvBmap.c) or text (tkCanvText.c).<BR>
The easiest way to create a new type manager is to copy the code<BR>
for an existing type and modify it for the new type.<BR>
<P>
Tk provides a number of utility procedures for the use of canvas<BR>
type managers, such as <B>Tk_CanvasCoords</B> and <B>Tk_CanvasPsColor</B>;<BR>
these are described in separate manual entries.<BR>
<BR>
<A NAME=Section0><H2>DATA STRUCTURES</H2>
</A><P>
A type manager consists of a collection of procedures that provide a<BR>
standard set of operations on items of that type.<BR>
The type manager deals with three kinds of data<BR>
structures.<BR>
The first data structure is a Tk_ItemType; it contains<BR>
information such as the name of the type and pointers to<BR>
the standard procedures implemented by the type manager:<BR>
<BR>
<DL>
typedef struct Tk_ItemType {<BR>
<DL>
char *<I>name</I>;<BR>
int <I>itemSize</I>;<BR>
Tk_ItemCreateProc *<I>createProc</I>;<BR>
Tk_ConfigSpec *<I>configSpecs</I>;<BR>
Tk_ItemConfigureProc *<I>configProc</I>;<BR>
Tk_ItemCoordProc *<I>coordProc</I>;<BR>
Tk_ItemDeleteProc *<I>deleteProc</I>;<BR>
Tk_ItemDisplayProc *<I>displayProc</I>;<BR>
int <I>alwaysRedraw</I>;<BR>
Tk_ItemPointProc *<I>pointProc</I>;<BR>
Tk_ItemAreaProc *<I>areaProc</I>;<BR>
Tk_ItemPostscriptProc *<I>postscriptProc</I>;<BR>
Tk_ItemScaleProc *<I>scaleProc</I>;<BR>
Tk_ItemTranslateProc *<I>translateProc</I>;<BR>
Tk_ItemIndexProc *<I>indexProc</I>;<BR>
Tk_ItemCursorProc *<I>icursorProc</I>;<BR>
Tk_ItemSelectionProc *<I>selectionProc</I>;<BR>
Tk_ItemInsertProc *<I>insertProc</I>;<BR>
Tk_ItemDCharsProc *<I>dCharsProc</I>;<BR>
Tk_ItemType *<I>nextPtr</I>;<BR>
</DL>
} Tk_ItemType;<BR>
</DL>
<BR>
<P>
The fields of a Tk_ItemType structure are described in more detail
later in this manual entry.
When <B>Tk_CreateItemType</B> is called, its <I>typePtr</I>
argument must point to a structure with all of the fields initialized
except <I>nextPtr</I>, which Tk sets to link all the types together
into a list.
The structure must be in permanent memory (either statically
allocated or dynamically allocated but never freed);  Tk retains
a pointer to this structure.
<P>
The second data structure manipulated by a type manager is an
<I>item record</I>.
For each item in a canvas there exists one item record.
All of the items of a given type generally have item records with
the same structure, but different types usually have different
formats for their item records.
The first part of each item record is a header with a standard structure
defined by Tk via the type Tk_Item;  the rest of the item
record is defined by the type manager.
A type manager must define its item records with a Tk_Item as
the first field.
For example, the item record for bitmap items is defined as follows:
<BR>
<DL>
typedef struct BitmapItem {<BR>
<DL>
Tk_Item <I>header</I>;<BR>
double <I>x</I>, <I>y</I>;<BR>
Tk_Anchor <I>anchor</I>;<BR>
Pixmap <I>bitmap</I>;<BR>
XColor *<I>fgColor</I>;<BR>
XColor *<I>bgColor</I>;<BR>
GC <I>gc</I>;<BR>
</DL>
} BitmapItem;<BR>
</DL>
<BR>
The <I>header</I> substructure contains information used by Tk
to manage the item, such as its identifier, its tags, its type,
and its bounding box.
The fields starting with <I>x</I> belong to the type manager:
Tk will never read or write them.
The type manager should not need to read or write any of the
fields in the header except for four fields
whose names are <I>x1</I>, <I>y1</I>, <I>x2</I>, and <I>y2</I>.
These fields give a bounding box for the items using integer
canvas coordinates:  the item should not cover any pixels
with x-coordinate lower than <I>x1</I> or y-coordinate
lower than <I>y1</I>, nor should it cover any pixels with
x-coordinate greater than or equal to <I>x2</I> or y-coordinate
greater than or equal to <I>y2</I>.
It is up to the type manager to keep the bounding box up to
date as the item is moved and reconfigured.
<P>
Whenever Tk calls a procedure in a type manager it passes in a pointer
to an item record.
The argument is always passed as a pointer to a Tk_Item;  the type
manager will typically cast this into a pointer to its own specific
type, such as BitmapItem.
<P>
The third data structure used by type managers has type
Tk_Canvas;  it serves as an opaque handle for the canvas widget
as a whole.
Type managers need not know anything about the contents of this
structure.
A Tk_Canvas handle is typically passed in to the
procedures of a type manager, and the type manager can pass the
handle back to library procedures such as Tk_CanvasTkwin
to fetch information about the canvas.

<A NAME=NAME><H2>NAME</H2>
</A><P>
This section and the ones that follow describe each of the fields
in a Tk_ItemType structure in detail.
The <I>name</I> field provides a string name for the item type.
Once <B>Tk_CreateImageType</B> returns, this name may be used
in <B>create</B> widget commands to create items of the new
type.
If there already existed an item type by this name then
the new item type replaces the old one.

<A NAME=ITEMSIZE><H2>ITEMSIZE</H2>
</A><I>typePtr-&gt;itemSize</I> gives the size in bytes of item records
of this type, including the Tk_Item header.
Tk uses this size to allocate memory space for items of the type.
All of the item records for a given type must have the same size.
If variable length fields are needed for an item (such as a list
of points for a polygon), the type manager can allocate a separate
object of variable length and keep a pointer to it in the item record.

<A NAME=CREATEPROC><H2>CREATEPROC</H2>
</A><P>
<I>typePtr-&gt;createProc</I> points to a procedure for
Tk to call whenever a new item of this type is created.
<I>typePtr-&gt;createProc</I> must match the following prototype:
<BR>
<DL>
typedef int Tk_ItemCreateProc(<BR>
<DL>
Tcl_Interp *<I>interp</I>,<BR>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
int <I>argc</I>,<BR>
char **<I>argv</I>);<BR>
</DL>
</DL>
<BR>
The <I>interp</I> argument is the interpreter in which the canvas's
<B>create</B> widget command was invoked, and <I>canvas</I> is a
handle for the canvas widget.
<I>itemPtr</I> is a pointer to a newly-allocated item of
size <I>typePtr-&gt;itemSize</I>.
Tk has already initialized the item's header (the first
<B>sizeof(Tk_ItemType)</B> bytes).
The <I>argc</I> and <I>argv</I> arguments describe all of the
arguments to the <B>create</B> command after the <I>type</I>
argument.
For example, in the widget command
<BR>
<PRE>
<B>.c create rectangle 10 20 50 50 -fill black</B><BR>
<BR>
</PRE>
<I>argc</I> will be <B>6</B> and <I>argv</I>[0] will contain the
string <B>10</B>.
<P>
<I>createProc</I> should use <I>argc</I> and <I>argv</I> to initialize
the type-specific parts of the item record and set an initial value
for the bounding box in the item's header.
It should return a standard Tcl completion code and leave an
error message in <I>interp-&gt;result</I> if an error occurs.
If an error occurs Tk will free the item record, so <I>createProc</I>
must be sure to leave the item record in a clean state if it returns an error
(e.g., it must free any additional memory that it allocated for
the item).

<A NAME=CONFIGSPECS><H2>CONFIGSPECS</H2>
</A><P>
Each type manager must provide a standard table describing its
configuration options, in a form suitable for use with
<B>Tk_ConfigureWidget</B>.
This table will normally be used by <I>typePtr-&gt;createProc</I>
and <I>typePtr-&gt;configProc</I>, but Tk also uses it directly
to retrieve option information in the <B>itemcget</B> and
<B>itemconfigure</B> widget commands.
<I>typePtr-&gt;configSpecs</I> must point to the configuration table
for this type.
Note: Tk provides a custom option type <B>tk_CanvasTagsOption</B>
for implementing the <B>-tags</B> option;  see an existing type
manager for an example of how to use it in <I>configSpecs</I>.

<A NAME=CONFIGPROC><H2>CONFIGPROC</H2>
</A><P>
<I>typePtr-&gt;configProc</I> is called by Tk whenever the
<B>itemconfigure</B> widget command is invoked to change the
configuration options for a canvas item.
This procedure must match the following prototype:
<BR>
<DL>
typedef int Tk_ItemConfigureProc(<BR>
<DL>
Tcl_Interp *<I>interp</I>,<BR>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
int <I>argc</I>,<BR>
char **<I>argv</I>,<BR>
int <I>flags</I>);<BR>
</DL>
</DL>
<BR>
The <I>interp</I> argument identifies the interpreter in which the
widget command was invoked,  <I>canvas</I> is a handle for the canvas
widget, and <I>itemPtr</I> is a pointer to the item being configured.
<I>argc</I> and <I>argv</I> contain the configuration options.  For
example, if the following command is invoked:
<BR>
<PRE>
<B>.c itemconfigure 2 -fill red -outline black</B><BR>
<BR>
</PRE>
<I>argc</I> is <B>4</B> and <I>argv</I> contains the strings <B>-fill</B>
through <B>black</B>.
<I>argc</I> will always be an even value.
The  <I>flags</I> argument contains flags to pass to <B>Tk_ConfigureWidget</B>;
currently this value is always TK_CONFIG_ARGV_ONLY when Tk
invokes <I>typePtr-&gt;configProc</I>, but the type manager's <I>createProc</I>
procedure will usually invoke <I>configProc</I> with different flag values.
<P>
<I>typePtr-&gt;configProc</I> returns a standard Tcl completion code and
leaves an error message in <I>interp-&gt;result</I> if an error occurs.
It must update the item's bounding box to reflect the new configuration
options.

<A NAME=COORDPROC><H2>COORDPROC</H2>
</A><P>
<I>typePtr-&gt;coordProc</I> is invoked by Tk to implement the <B>coords</B>
widget command for an item.
It must match the following prototype:
<BR>
<DL>
typedef int Tk_ItemCoordProc(<BR>
<DL>
Tcl_Interp *<I>interp</I>,<BR>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
int <I>argc</I>,<BR>
char **<I>argv</I>);<BR>
</DL>
</DL>
<BR>
The arguments <I>interp</I>, <I>canvas</I>, and <I>itemPtr</I>
all have the standard meanings, and <I>argc</I> and <I>argv</I>
describe the coordinate arguments.
For example, if the following widget command is invoked:
<BR>
<PRE>
<B>.c coords 2 30 90</B><BR>
<BR>
</PRE>
<I>argc</I> will be <B>2</B> and <B>argv</B> will contain the string values
<B>30</B> and <B>90</B>.
<P>
The <I>coordProc</I> procedure should process the new coordinates,
update the item appropriately (e.g., it must reset the bounding
box in the item's header), and return a standard Tcl completion
code.
If an error occurs, <I>coordProc</I> must leave an error message in
<I>interp-&gt;result</I>.

<A NAME=DELETEPROC><H2>DELETEPROC</H2>
</A><P>
<I>typePtr-&gt;deleteProc</I> is invoked by Tk to delete an item
and free any resources allocated to it.
It must match the following prototype:
<BR>
<DL>
typedef void Tk_ItemDeleteProc(<BR>
<DL>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
Display *<I>display</I>);<BR>
</DL>
</DL>
<BR>
The <I>canvas</I> and <I>itemPtr</I> arguments have the usual
interpretations, and <I>display</I> identifies the X display containing
the canvas.
<I>deleteProc</I> must free up any resources allocated for the item,
so that Tk can free the item record.
<I>deleteProc</I> should not actually free the item record;  this will
be done by Tk when <I>deleteProc</I> returns.

<A NAME=Section1><H2>DISPLAYPROC AND ALWAYSREDRAW</H2>
</A><P>
<I>typePtr-&gt;displayProc</I> is invoked by Tk to redraw an item
on the screen.
It must match the following prototype:
<BR>
<DL>
typedef void Tk_ItemDisplayProc(<BR>
<DL>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
Display *<I>display</I>,<BR>
Drawable <I>dst</I>,<BR>
int <I>x</I>,<BR>
int <I>y</I>,<BR>
int <I>width</I>,<BR>
int <I>height</I>);<BR>
</DL>
</DL>
<BR>
The <I>canvas</I> and <I>itemPtr</I> arguments have the usual meaning.
<I>display</I> identifies the display containing the canvas, and
<I>dst</I> specifies a drawable in which the item should be rendered;
typically this is an off-screen pixmap, which Tk will copy into
the canvas's window once all relevant items have been drawn.
<I>x</I>, <I>y</I>, <I>width</I>, and <I>height</I> specify a rectangular
region in canvas coordinates, which is the area to be redrawn;
only information that overlaps this area needs to be redrawn.
Tk will not call <I>displayProc</I> unless the item's bounding box
overlaps the redraw area, but the type manager may wish to use
the redraw area to optimize the redisplay of the item.
<P>
Because of scrolling and the use of off-screen pixmaps for
double-buffered redisplay, the item's coordinates in <I>dst</I>
will not necessarily be the same as those in the canvas.
<I>displayProc</I> should call <B>Tk_CanvasDrawableCoords</B>
to transform coordinates from those of the canvas to those
of <I>dst</I>.
<P>
Normally an item's <I>displayProc</I> is only invoked if the item
overlaps the area being displayed.
However, if <I>typePtr-&gt;alwaysRedraw</I> has a non-zero value, then
<I>displayProc</I> is invoked during every redisplay operation,
even if the item doesn't overlap the area of redisplay.
<I>alwaysRedraw</I> should normally be set to 0;  it is only
set to 1 in special cases such as window items that need to be
unmapped when they are off-screen.

<A NAME=POINTPROC><H2>POINTPROC</H2>
</A><P>
<I>typePtr-&gt;pointProc</I> is invoked by Tk to find out how close
a given point is to a canvas item.
Tk uses this procedure for purposes such as locating the item
under the mouse or finding the closest item to a given point.
The procedure must match the following prototype:
<BR>
<DL>
typedef double Tk_ItemPointProc(<BR>
<DL>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
double *<I>pointPtr</I>);<BR>
</DL>
</DL>
<BR>
<I>canvas</I> and <I>itemPtr</I> have the usual meaning.
<I>pointPtr</I> points to an array of two numbers giving
the x and y coordinates of a point.
<I>pointProc</I> must return a real value giving the distance
from the point to the item, or 0 if the point lies inside
the item.

<A NAME=AREAPROC><H2>AREAPROC</H2>
</A><P>
<I>typePtr-&gt;areaProc</I> is invoked by Tk to find out the relationship
between an item and a rectangular area.
It must match the following prototype:
<BR>
<DL>
typedef int Tk_ItemAreaProc(<BR>
<DL>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
double *<I>rectPtr</I>);<BR>
</DL>
</DL>
<BR>
<I>canvas</I> and <I>itemPtr</I> have the usual meaning.
<I>rectPtr</I> points to an array of four real numbers;
the first two give the x and y coordinates of the upper left
corner of a rectangle, and the second two give the x and y
coordinates of the lower right corner.
<I>areaProc</I> must return -1 if the item lies entirely outside
the given area, 0 if it lies partially inside and partially
outside the area, and 1 if it lies entirely inside the area.

<A NAME=POSTSCRIPTPROC><H2>POSTSCRIPTPROC</H2>
</A><P>
<I>typePtr-&gt;postscriptProc</I> is invoked by Tk to generate
Postcript for an item during the <B>postscript</B> widget command.
If the type manager is not capable of generating Postscript then
<I>typePtr-&gt;postscriptProc</I> should be NULL.
The procedure must match the following prototype:
<BR>
<DL>
typedef int Tk_ItemPostscriptProc(<BR>
<DL>
Tcl_Interp *<I>interp</I>,<BR>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
int <I>prepass</I>);<BR>
</DL>
</DL>
<BR>
The <I>interp</I>, <I>canvas</I>, and <I>itemPtr</I> arguments all have
standard meanings;  <I>prepass</I> will be described below.
If <I>postscriptProc</I> completes successfully, it should append
Postscript for the item to the information in <I>interp-&gt;result</I>
(e.g. by calling <B>Tcl_AppendResult</B>, not <B>Tcl_SetResult</B>)
and return TCL_OK.
If an error occurs, <I>postscriptProc</I> should clear the result
and replace its contents with an error message;  then it should
return TCL_ERROR.
<P>
Tk provides a collection of utility procedures to simplify
<I>postscriptProc</I>.
For example, <B>Tk_CanvasPsColor</B> will generate Postscript to set
the current color to a given Tk color and <B>Tk_CanvasPsFont</B> will
set up font information.
When generating Postscript, the type manager is free to change the
graphics state of the Postscript interpreter, since Tk places
<B>gsave</B> and <B>grestore</B> commands around the Postscript for
the item.
The type manager can use canvas x coordinates directly in its Postscript,
but it must call <B>Tk_CanvasPsY</B> to convert y coordinates from
the space of the canvas (where the origin is at the
upper left) to the space of Postscript (where the origin is at the
lower left).
<P>
In order to generate Postscript that complies with the Adobe Document
Structuring Conventions, Tk actually generates Postscript in two passes.
It calls each item's <I>postscriptProc</I> in each pass.
The only purpose of the first pass is to collect font information
(which is done by <B>Tk_CanvPsFont</B>);  the actual Postscript is
discarded.
Tk sets the <I>prepass</I> argument to <I>postscriptProc</I> to 1
during the first pass;  the type manager can use <I>prepass</I> to skip
all Postscript generation except for calls to <B>Tk_CanvasPsFont</B>.
During the second pass <I>prepass</I> will be 0, so the type manager
must generate complete Postscript.

<A NAME=SCALEPROC><H2>SCALEPROC</H2>
</A><I>typePtr-&gt;scaleProc</I> is invoked by Tk to rescale a canvas item
during the <B>scale</B> widget command.
The procedure must match the following prototype:
<BR>
<DL>
typedef void Tk_ItemScaleProc(<BR>
<DL>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
double <I>originX</I>,<BR>
double <I>originY</I>,<BR>
double <I>scaleX</I>,<BR>
double <I>scaleY</I>);<BR>
</DL>
</DL>
<BR>
The <I>canvas</I> and <I>itemPtr</I> arguments have the usual meaning.
<I>originX</I> and <I>originY</I> specify an origin relative to which
the item is to be scaled, and <I>scaleX</I> and <I>scaleY</I> give the
x and y scale factors.
The item should adjust its coordinates so that a point in the item
that used to have coordinates <I>x</I> and <I>y</I> will have new
coordinates <I>x'</I> and <I>y'</I>, where
<BR>
<PRE>
<I>x' = originX  + scaleX*(x-originX)</I><BR>
y' = originY + scaleY*(y-originY)<BR>
<BR>
</PRE>
<I>scaleProc</I> must also update the bounding box in the item's
header.

<A NAME=TRANSLATEPROC><H2>TRANSLATEPROC</H2>
</A><I>typePtr-&gt;translateProc</I> is invoked by Tk to translate a canvas item
during the <B>move</B> widget command.
The procedure must match the following prototype:
<BR>
<DL>
typedef void Tk_ItemTranslateProc(<BR>
<DL>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
double <I>deltaX</I>,<BR>
double <I>deltaY</I>);<BR>
</DL>
</DL>
<BR>
The <I>canvas</I> and <I>itemPtr</I> arguments have the usual meaning,
and <I>deltaX</I> and <I>deltaY</I> give the amounts that should be
added to each x and y coordinate within the item.
The type manager should adjust the item's coordinates and
update the bounding box in the item's header.

<A NAME=INDEXPROC><H2>INDEXPROC</H2>
</A><I>typePtr-&gt;indexProc</I> is invoked by Tk to translate a string
index specification into a numerical index, for example during the
<B>index</B> widget command.
It is only relevant for item types that support indexable text;
<I>typePtr-&gt;indexProc</I> may be specified as NULL for non-textual
item types.
The procedure must match the following prototype:
<BR>
<DL>
typedef int Tk_ItemIndexProc(<BR>
<DL>
Tcl_Interp *<I>interp</I>,<BR>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
char <I>indexString</I>,<BR>
int *<I>indexPtr</I>);<BR>
</DL>
</DL>
<BR>
The <I>interp</I>, <I>canvas</I>, and <I>itemPtr</I> arguments all
have the usual meaning.
<I>indexString</I> contains a textual description of an index,
and <I>indexPtr</I> points to an integer value that should be
filled in with a numerical index.
It is up to the type manager to decide what forms of index
are supported (e.g., numbers, <B>insert</B>,  <B>sel.first</B>,
<B>end</B>, etc.).
<I>indexProc</I> should return a Tcl completion code and set
<I>interp-&gt;result</I> in the event of an error.

<A NAME=ICURSORPROC><H2>ICURSORPROC</H2>
</A><P>
<I>typePtr-&gt;icursorProc</I> is invoked by Tk during
the <B>icursor</B> widget command to set the position of the
insertion cursor in a textual item.
It is only relevant for item types that support an insertion cursor;
<I>typePtr-&gt;icursorProc</I> may be specified as NULL for item types
that don't support an insertion cursor.
The procedure must match the following prototype:
<BR>
<DL>
typedef void Tk_ItemIndexProc(<BR>
<DL>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
int <I>index</I>);<BR>
</DL>
</DL>
<BR>
<I>canvas</I> and <I>itemPtr</I> have the usual meanings, and
<I>index</I> is an index into the item's text, as returned by a
previous call to <I>typePtr-&gt;insertProc</I>.
The type manager should position the insertion cursor in the
item just before the character given by <I>index</I>.
Whether or not to actually display the insertion cursor is
determined by other information provided by <B>Tk_CanvasGetTextInfo</B>.

<A NAME=SELECTIONPROC><H2>SELECTIONPROC</H2>
</A><P>
<I>typePtr-&gt;selectionProc</I> is invoked by Tk during selection
retrievals;  it must return part or all of the selected text in
the item (if any).
It is only relevant for item types that support text;
<I>typePtr-&gt;selectionProc</I> may be specified as NULL for non-textual
item types.
The procedure must match the following prototype:
<BR>
<DL>
typedef int Tk_ItemSelectionProc(<BR>
<DL>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
int <I>offset</I>,<BR>
char *<I>buffer</I>,<BR>
int <I>maxBytes</I>);<BR>
</DL>
</DL>
<BR>
<I>canvas</I> and <I>itemPtr</I> have the usual meanings.
<I>offset</I> is an offset in bytes into the selection where 0 refers
to the first byte of the selection;  it identifies
the first character that is to be returned in this call.
<I>buffer</I> points to an area of memory in which to store the
requested bytes, and <I>maxBytes</I> specifies the maximum number
of bytes to return.
<I>selectionProc</I> should extract up to <I>maxBytes</I> characters
from the selection and copy them to <I>maxBytes</I>;  it should
return a count of the number of bytes actually copied, which may
be less than <I>maxBytes</I> if there aren't <I>offset+maxBytes</I> bytes
in the selection.

<A NAME=INSERTPROC><H2>INSERTPROC</H2>
</A><P>
<I>typePtr-&gt;insertProc</I> is invoked by Tk during
the <B>insert</B> widget command to insert new text into a
canvas item.
It is only relevant for item types that support text;
<I>typePtr-&gt;insertProc</I> may be specified as NULL for non-textual
item types.
The procedure must match the following prototype:
<BR>
<DL>
typedef void Tk_ItemInsertProc(<BR>
<DL>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
int <I>index</I>,<BR>
char *<I>string</I>);<BR>
</DL>
</DL>
<BR>
<I>canvas</I> and <I>itemPtr</I> have the usual meanings.
<I>index</I> is an index into the item's text, as returned by a
previous call to <I>typePtr-&gt;insertProc</I>, and <I>string</I>
contains new text to insert just before the character given
by <I>index</I>.
The type manager should insert the text and recompute the bounding
box in the item's header.

<A NAME=DCHARSPROC><H2>DCHARSPROC</H2>
</A><P>
<I>typePtr-&gt;dCharsProc</I> is invoked by Tk during the <B>dchars</B>
widget command to delete a range of text from a canvas item.
It is only relevant for item types that support text;
<I>typePtr-&gt;dCharsProc</I> may be specified as NULL for non-textual
item types.
The procedure must match the following prototype:
<BR>
<DL>
typedef void Tk_ItemDCharsProc(<BR>
<DL>
Tk_Canvas <I>canvas</I>,<BR>
Tk_Item *<I>itemPtr</I>,<BR>
int <I>first</I>,<BR>
int <I>last</I>);<BR>
</DL>
</DL>
<BR>
<I>canvas</I> and <I>itemPtr</I> have the usual meanings.
<I>first</I> and <I>last</I> give the indices of the first and last bytes
to be deleted, as returned by previous calls to <I>typePtr-&gt;indexProc</I>.
The type manager should delete the specified characters and update
the bounding box in the item's header.

<A NAME=Section2><H2>SEE ALSO</H2>
</A><A HREF="CanvPsY.ht"> Tk_CanvasPsY</A>, <A HREF="CanvTxtInfo.ht"> Tk_CanvasTextInfo</A>, <A HREF="CanvTkwin.ht"> Tk_CanvasTkwin</A>

<A NAME=KEYWORDS><H2>KEYWORDS</H2>
</A>canvas, focus, item type, selection, type manager
