<HTML>
<! Copyright (c) 1990 The Regents of the University of California.-->
<! Copyright (c) 1994 Sun Microsystems, Inc.-->
<! See the file "license.terms" for information on usage and redistribution-->
<! of this file, and for a DISCLAIMER OF ALL WARRANTIES.-->
<! -->
<! @(#) Preserve.3 1.7 95/05/06 15:30:19-->
<! -->
<H1>Tk_Preserve</H1>
<HR>
<A NAME=NAME><H2>NAME</H2>
</A>Tk_Preserve, Tk_Release, Tk_EventuallyFree - avoid freeing storage while it's being used
<A NAME=SYNOPSIS><H2>SYNOPSIS</H2>
</A><BR>
<B>#include &lt;tk.h&gt;</B><BR>
<P>
<B>Tk_Preserve</B>(<I>clientData</I>)<BR>
<P>
<B>Tk_Release</B>(<I>clientData</I>)<BR>
<P>
<B>Tk_EventuallyFree</B>(<I>clientData, freeProc</I>)<BR>
<A NAME=ARGUMENTS><H2>ARGUMENTS</H2>
</A><DL>
<DT><CODE>ClientData clientData</CODE>
(in) <DD>Token describing structure to be freed or reallocated.  Usually a pointer<BR>
to memory for structure.<BR>
<DT><CODE>Tk_FreeProc *freeProc</CODE>
(in) <DD>Procedure to invoke to free <I>clientData</I>.<BR>
</DL>
<HR>
<BR>
<A NAME=DESCRIPTION><H2>DESCRIPTION</H2>
</A><P>
These three procedures help implement a simple reference count mechanism<BR>
for managing storage.  They are designed to solve a problem<BR>
having to do with widget deletion.  When a widget is deleted, its<BR>
widget record (the structure holding information specific to the<BR>
widget) must be returned to the storage allocator.<BR>
However, it's possible that the widget record is in active use<BR>
by one of the procedures on the stack at the time of the deletion.<BR>
This can happen, for example, if the command associated with a button<BR>
widget causes the button to be destroyed:  an X event causes an<BR>
event-handling C procedure in the button to be invoked, which in<BR>
turn causes the button's associated Tcl command to be executed,<BR>
which in turn causes the button to be deleted, which in turn causes<BR>
the button's widget record to be de-allocated.<BR>
Unfortunately, when the Tcl command returns, the button's<BR>
event-handling procedure will need to reference the<BR>
button's widget record.<BR>
Because of this, the widget record must not be freed as part of the<BR>
deletion, but must be retained until the event-handling procedure has<BR>
finished with it.<BR>
In other situations where the widget is deleted, it may be possible<BR>
to free the widget record immediately.<BR>
<P>
<B>Tk_Preserve</B> and <B>Tk_Release</B><BR>
implement short-term reference counts for their <I>clientData</I><BR>
argument.<BR>
The <I>clientData</I> argument identifies an object and usually<BR>
consists of the address of a structure.<BR>
The reference counts guarantee that an object will not be freed<BR>
until each call to <B>Tk_Preserve</B> for the object has been<BR>
matched by calls to <B>Tk_Release</B>.<BR>
There may be any number of unmatched <B>Tk_Preserve</B> calls<BR>
in effect at once.<BR>
<P>
<B>Tk_EventuallyFree</B> is invoked to free up its <I>clientData</I><BR>
argument.<BR>
It checks to see if there are unmatched <B>Tk_Preserve</B> calls<BR>
for the object.<BR>
If not, then <B>Tk_EventuallyFree</B> calls <I>freeProc</I> immediately.<BR>
Otherwise <B>Tk_EventuallyFree</B> records the fact that <I>clientData</I><BR>
needs eventually to be freed.<BR>
When all calls to <B>Tk_Preserve</B> have been matched with<BR>
calls to <B>Tk_Release</B> then <I>freeProc</I> will be called by<BR>
<B>Tk_Release</B> to do the cleanup.<BR>
<P>
All the work of freeing the object is carried out by <I>freeProc</I>.<BR>
<I>FreeProc</I> must have arguments and result that match the<BR>
type <B>Tk_FreeProc</B>:<BR>
<BR>
<DL>
typedef void Tk_FreeProc(ClientData <I>clientData</I>);<BR>
</DL>
<BR>
The <I>clientData</I> argument to <I>freeProc</I> will be the
same as the <I>clientData</I> argument to <B>Tk_EventuallyFree</B>.
<P>
This mechanism can be used to solve the problem described above
by placing <B>Tk_Preserve</B> and <B>Tk_Release</B> calls around
actions that may cause undesired storage re-allocation.  The
mechanism is intended only for short-term use (i.e. while procedures
are pending on the stack);  it will not work efficiently as a
mechanism for long-term reference counts.
The implementation does not depend in any way on the internal
structure of the objects being freed;  it keeps the reference
counts in a separate structure.

<A NAME=KEYWORDS><H2>KEYWORDS</H2>
</A>free, reference count, storage
