<HTML>
<! Copyright (c) 1994 The Regents of the University of California.-->
<! Copyright (c) 1994 Sun Microsystems, Inc.-->
<! See the file "license.terms" for information on usage and redistribution-->
<! of this file, and for a DISCLAIMER OF ALL WARRANTIES.-->
<! -->
<! @(#) fileevent.n 1.5 95/05/06 15:31:02-->
<! -->
<H1>fileevent</H1>
<HR>
<! Note:  do not modify the .SH NAME line immediately below!-->
<A NAME=NAME><H2>NAME</H2>
</A>fileevent - Execute a script when a file becomes readable or writable
<A NAME=SYNOPSIS><H2>SYNOPSIS</H2>
</A><B>fileevent </B><I>fileId </I><B>readable </B>?<I>script</I>?
<BR>
<B>fileevent </B><I>fileId </I><B>writable </B>?<I>script</I>?
<HR>

<A NAME=DESCRIPTION><H2>DESCRIPTION</H2>
</A><P>
This command is used to create <I>file event handlers</I>.
A file event handler is a binding between a file and a script,
such that the script is evaluated whenever the file becomes
readable or writable.
File event handlers are most commonly used to allow data to be
received from a child process on an event-driven basis, so that
the receiver can continue to interact with the user while
waiting for the data to arrive.
If an application invokes <B>gets</B> or <B>read</B> when there
is no input data available, the process will block;  until the
input data arrives, it will not be able to service other events,
so it will appear to the user to ``freeze up''.
With <B>fileevent</B>, the process can tell when data is present
and only invoke <B>gets</B> or <B>read</B> when they won't block.
<P>
The <I>fileId</I> argument to <B>fileevent</B> refers to an open file;
it must be <B>stdin</B>, <B>stdout</B>, <B>stderr</B>, or the return value
from some previous <B>open</B> command.
If the <I>script</I> argument is specified, then <B>fileevent</B>
creates a new event handler:  <I>script</I> will be evaluated
whenever the file becomes readable or writable (depending on the
second argument to <B>fileevent</B>).
In this case <B>fileevent</B> returns an empty string.
The <B>readable</B> and <B>writable</B> event handlers for a file
are independent, and may be created and deleted separately.
However, there may be at most one <B>readable</B> and one <B>writable</B>
handler for a file at a given time.
If <B>fileevent</B> is called when the specified handler already
exists, the new script replaces the old one.
<P>
If the <I>script</I> argument is not specified, <B>fileevent</B>
returns the current script for <I>fileId</I>, or an empty string
if there is none.
If the <I>script</I> argument is specified as an empty string
then the event handler is deleted, so that no script will be invoked.
A file event handler is also deleted automatically whenever
its file is closed or its interpreter is deleted.
<P>
A file is considered to be readable whenever the <B>gets</B>
and <B>read</B> commands can return without blocking.
A file is also considered to be readable if an end-of-file or
error condition is present.
It is important for <I>script</I> to check for these conditions
and handle them appropriately;  for example, if there is no special
check for end-of-file, an infinite loop may occur where <I>script</I>
reads no data, returns, and is immediately invoked again.
<P>
When using <B>fileevent</B> for event-driven I/O, it's important
to read the file in the same units that are written
from the other end.
For example, suppose that you are using <B>fileevent</B> to
read data generated by a child process.
If the child process is writing whole lines, then you should use
<B>gets</B> to read those lines.
If the child generates one line at a time then you shouldn't
make more than a single call to <B>gets</B> in <I>script</I>: the first call
will consume all the available data, so the second call may block.
You can also use <B>read</B> to read the child's data, but only
if you know how many bytes the child is writing at a time:  if
you try to read more bytes than the child has written, the
<B>read</B> call will block.
<P>
A file is considered to be writable if at least one byte of data
can be written to the file without blocking, or if an error condition
is present.
Write handlers are probably not very useful without additional command
support.
The <B>puts</B> command is dangerous since it write more than
one byte at a time and may thus block.
What is really needed is a new non-blocking form of write that
saves any data that couldn't be written to the file.
<P>
The script for a file event is executed at global level (outside the
context of any Tcl procedure).
If an error occurs while executing the script then the
<B>tkerror</B> mechanism is used to report the error.
In addition, the file event handler is deleted if it ever returns
an error;  this is done in order to prevent infinite loops due to
buggy handlers.

<A NAME=CREDITS><H2>CREDITS</H2>
</A><P>
<B>fileevent</B> is based on the <B>addinput</B> command created
by Mark Diekhans.

<A NAME=Section0><H2>SEE ALSO</H2>
</A><A HREF="tkerror.ht"> tkerror</A>

<A NAME=KEYWORDS><H2>KEYWORDS</H2>
</A>asynchronous I/O, event handler, file, readable, script, writable
